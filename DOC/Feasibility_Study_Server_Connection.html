<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기술 검토: 영역 기반 서버 연결 (Zone-based Server Connection)</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-orange: #d29922;
            --border-color: #30363d;
        }

        body {
            font-family: 'Segoe UI', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            color: var(--accent-orange);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        h2 {
            color: var(--accent-blue);
            margin-top: 2rem;
        }

        h3 {
            color: var(--text-secondary);
            margin-top: 1.5rem;
        }

        .box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            border-left: 5px solid var(--accent-blue);
        }

        .warning-box {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        code {
            background: rgba(110, 118, 129, 0.4);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            color: #d2a8ff;
        }
    </style>
</head>

<body>

    <h1>🔍 기술 검토: 영역 기반 서버 연결</h1>
    <p><strong>주제:</strong> 일반 필드(TCP)에서 특정 영역(Bounding Box) 진입 시 데디케이티드 서버(UDP)와 연결 가능한가?</p>

    <div class="box">
        <h3>💡 실행 요약 (Executive Summary)</h3>
        <p>
            단일 월드 내에서 <strong>'부분적 리플리케이션'을 하는 것은 불가능</strong>합니다.
            (클라이언트는 동시에 하나의 World Context만 가질 수 있음)<br>
            하지만 <strong>Seamless Server Travel</strong> 기술을 사용하면,
            유저가 경계선을 넘을 때 <strong>끊김 없이(Loading Screen 없이)</strong> 서버 세션으로 이동하는 MMO 스타일의 구현은 가능합니다.
        </p>
    </div>

    <h2>1. 핵심 제약 사항 (Technical Constraints)</h2>

    <div class="warning-box">
        <h3>⛔ 단일 월드 원칙 (One World Rule)</h3>
        <p>언리얼 엔진의 클라이언트는 한 번에 <strong>단 하나의 <code>UWorld</code></strong>만 가질 수 있습니다.</p>
        <ul>
            <li><strong>TCP 필드 모드:</strong> 클라이언트는 로컬 PC에 존재하는 <code>Standalone World</code>를 보고 있습니다.</li>
            <li><strong>UDP 던전 모드:</strong> 클라이언트는 서버 PC에 존재하는 <code>Server World</code>를 복제(Replication)해서 보고 있습니다.
            </li>
        </ul>
        <p>따라서, 발은 로컬 월드에 두고 팔은 서버 월드에 넣는 형태의 공존은 엔진 구조상 불가능합니다.</p>
    </div>

    <h2>2. 해결책: 심리스 트래블 (Seamless Travel)</h2>
    <p>사용자가 원하는 '자연스러운 진입'을 구현하는 표준 기술입니다.</p>

    <h3>2.1 작동 원리</h3>
    <ol>
        <li>유저가 <strong>진입 영역(Bounding Box)</strong>에 닿습니다.</li>
        <li>클라이언트가 백그라운드에서 서버 맵(Transition Map) 로딩을 시작합니다.</li>
        <li>로딩이 완료되면 기존 로컬 월드의 액터들을 정리하고 <strong>서버 세션으로 핸드셰이크</strong>합니다.</li>
        <li>이때 검은 로딩 화면 없이, 캐릭터가 계속 걷는 상태에서 주변 환경이 동기화 상태로 바뀝니다.</li>
    </ol>

    <h3>2.2 아키텍처 비교</h3>
    <table>
        <tr>
            <th>구분</th>
            <th>기존 방식 (Hard Loading)</th>
            <th>제안 방식 (Seamless Travel)</th>
        </tr>
        <tr>
            <td><strong>전환 시점</strong></td>
            <td>화면이 멈추고 로딩 바가 뜸</td>
            <td>캐릭터 조작 유지, 배경 비동기 로딩</td>
        </tr>
        <tr>
            <td><strong>TCP 연결</strong></td>
            <td>끊길 수 있음 (구조에 따라)</td>
            <td><code>GameInstance</code>에 유지되어 계속 연결됨</td>
        </tr>
        <tr>
            <td><strong>시각적 효과</strong></td>
            <td>화면 깜빡임</td>
            <td>안개/터널 통과 시 자연스러운 위상 변화</td>
        </tr>
    </table>

    <h2>3. 구현 전략 (Implementation Strategy)</h2>

    <h3>Step 1: 포탈(Portal) 영역 설정</h3>
    <pre><code class="cpp">// ATravelTriggerVolume.cpp
void ATravelTriggerVolume::OnOverlap(...)
{
    // 로컬 클라이언트에게 서버 접속 명령
    // IP:Port는 미리 받아둔 상태
    PlayerController->ClientTravel("127.0.0.1:7777", TRAVEL_Relative, bUseSeamlessTravel = true);
}</code></pre>

    <h3>Step 2: TCP 연결 유지 (GameInstance)</h3>
    <p>
        <code>UGameInstance</code>는 레벨이 바뀌거나 서버를 옮겨도 <strong>파괴되지 않고 유지</strong>됩니다.<br>
        따라서 <code>GsNetworkManager</code>는 반드시 <code>GameInstanceSubsystem</code>이어야 하며,
        서버 이동 중에도 채팅/인벤토리 데이터(TCP)를 유지할 수 있습니다.
    </p>

    <h2>4. 결론 및 제언</h2>
    <p>
        <strong>"영역에 진입하면 리플리케이션을 켠다"</strong>는 개념보다는,
        <strong>"영역에 진입하면 매끄럽게 서버로 이동(Travel)한다"</strong>는 개념으로 접근해야 합니다.
    </p>
    <p>
        이 방식은 MMO(로스트아크 등)에서 던전 입장 시 사용하는 방식과 동일하며,
        TCP(채팅/UI)와 UDP(전투)를 병행하는 Hybrid 아키텍처에 가장 적합합니다.
    </p>

</body>

</html>